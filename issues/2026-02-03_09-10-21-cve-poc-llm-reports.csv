id,priority,phase,area,title,description,acceptance_criteria,test_mcp,review_initial_requirements,review_regression_requirements,dev_state,review_initial_state,review_regression_state,git_state,owner,refs,notes
CPLR-01-01,P2,1,backend,创建运行入口脚本与 CLI 参数,新增 scripts/cve_poc_llm_reports.py 作为离线生成入口，支持 from-year/base_url/api_key/model/templates_dir/reports_dir；只读 nuclei-templates/，仅写入 reports/。,脚本存在且 `python scripts/cve_poc_llm_reports.py --help` 可展示所需参数；ref: openspec/changes/cve-poc-llm-reports/tasks.md:3; MUST 支持 `--from-year` 参数并解析为整数（过滤行为在 CPLR-02-03 验收）；ref: openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:16; 运行时可配置 `base_url/api_key/model`；ref: openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:51; 只读取 `nuclei-templates/` 不做修改，输出仅落在 `reports/`；ref: openspec/changes/cve-poc-llm-reports/design.md:18,AUTOSERVER,CLI 参数命名与 tasks 一致（含 templates_dir/reports_dir），无隐藏默认行为；日志/帮助信息不得泄露 `api_key`；入口层不应引入对 `nuclei-templates/` 的写操作（只读约束）。,回归确认仅新增 `reports/` 输出，不修改 `nuclei-templates/` 与其索引；ref: openspec/changes/cve-poc-llm-reports/proposal.md:22,已完成,已完成,已完成,已提交,,openspec/changes/cve-poc-llm-reports/tasks.md:3; openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:51; openspec/changes/cve-poc-llm-reports/design.md:18; scripts/cve_poc_llm_reports.py:1,Non-Goals: 不执行 nuclei、不做真实扫描；ref: openspec/changes/cve-poc-llm-reports/design.md:30; picked_reason:作为所有后续任务的入口与参数契约，优先落地以解锁后续实现/测试; acceptance_adjusted:from-year 过滤行为由 CPLR-02-03 覆盖，CPLR-01-01 仅验收参数/解析; done_at:2026-02-03; evidence:python3 scripts/cve_poc_llm_reports.py --help (参数展示/可解析)
CPLR-01-02,P2,1,backend,定义配置优先级（CLI > 环境变量）,实现配置加载与校验：CLI 参数优先，其次环境变量；缺失必填项时报错并以非 0 退出。,CLI 参数覆盖同名环境变量；ref: openspec/changes/cve-poc-llm-reports/tasks.md:4; 缺失 `api_key/base_url/model` 等必填项时明确报错并退出；ref: openspec/changes/cve-poc-llm-reports/tasks.md:4; 运行时配置能力满足 OpenAI Chat 参数要求；ref: openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:51,AUTOSERVER,配置层必须可测试（纯函数/可注入），错误信息明确可定位缺失项；不得在错误消息/日志中输出完整 `api_key`；base_url 处理需兼容尾部 `/`（避免拼接出双斜杠）。,确保默认行为不写死到固定域名，base_url 可配置；ref: openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:60,已完成,已完成,已完成,已提交,,openspec/changes/cve-poc-llm-reports/tasks.md:4; openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:51; openspec/changes/cve-poc-llm-reports/design.md:17; scripts/cve_poc_llm_reports.py:83,建议为 `base_url/api_key/model` 设计统一的 env key（如 `OPENAI_BASE_URL` 等），并在文档中说明。; picked_reason:基础配置契约（CLI/env/必填校验）会影响后续所有网络调用与可测试性; done_at:2026-02-03; evidence:缺失 base_url/api_key/model 时退出码=2 且错误列出缺失项（不泄露 api_key）; evidence:CLI 覆盖 env，base_url 尾部 / 会归一化（python3 snippet 验证）
CPLR-01-03,P2,1,backend,统一日志输出（进度/跳过/失败/成功计数）,提供统一日志格式，覆盖：处理进度、跳过原因、失败原因、成功计数，便于批处理可观测。,日志至少包含：处理进度、跳过原因、失败原因、成功计数；ref: openspec/changes/cve-poc-llm-reports/tasks.md:5; LLM 输出非 JSON 等失败需记录并继续后续 CVE；ref: openspec/changes/cve-poc-llm-reports/design.md:58,AUTOSERVER,日志字段尽量结构化（可 grep/统计），跳过/失败必须包含 CVE ID 与 file_path；禁止日志打印完整模板 YAML 或 `api_key`（仅在需要时打印截断摘要）。,批量运行出现单条失败时整体仍可完成（不中断）；ref: openspec/changes/cve-poc-llm-reports/design.md:58,已完成,已完成,已完成,已提交,,openspec/changes/cve-poc-llm-reports/tasks.md:5; openspec/changes/cve-poc-llm-reports/design.md:58; openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:93; scripts/cve_poc_llm_reports.py:40,picked_reason:统一结构化日志是批处理可观测性的底座，后续 skip/fail/ok 都复用; done_at:2026-02-03; evidence:event=start/summary 输出 + log_skip/log_failure/log_success 结构化字段（含 id/file_path/reason/计数）
CPLR-02-01,P2,2,backend,实现 JSONL 读取器（逐行解析 cves.json）,"逐行读取并解析 nuclei-templates/cves.json（JSONL），产出 {id, year, file_path} 流，为后续过滤与路径映射提供输入。",MUST 逐行读取并解析 `nuclei-templates/cves.json`；ref: openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:4; WHEN 存在包含 `ID` 与 `file_path` 的一行 → THEN 解析出 `id/year` 与读取路径；ref: openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:12; 实现为流式处理，不一次性加载全量（面向大规模存量 CVE）；ref: openspec/changes/cve-poc-llm-reports/design.md:26,AUTOSERVER,解析失败必须可定位到行号/内容摘要（避免整行过长日志）；读取路径拼接需防止 path traversal（file_path 必须相对且在 templates_dir 下）。,from-year 过滤前不应读取模板文件，降低 IO/成本；ref: openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:20,已完成,已完成,已完成,已提交,,openspec/changes/cve-poc-llm-reports/tasks.md:9; openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:4; openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:12; cve_poc_llm_reports/cves_jsonl.py:55; tests/test_cves_jsonl.py:1,picked_reason:输入枚举是整条流水线的起点，优先实现以解锁过滤/路径映射/幂等; done_at:2026-02-03; evidence:python3 -m unittest discover -s tests -v (test_cves_jsonl); evidence:iter_cves_jsonl streams nuclei-templates/cves.json and resolves template_path with traversal guard
CPLR-02-02,P2,2,backend,实现 ID 年份解析（仅接受 CVE-YYYY-...）,从 `ID`（CVE-YYYY-...）解析 year；非法格式计为失败并继续，不依赖 file_path 中年份目录。,MUST 以 `ID` 解析 CVE 年份并作为过滤/输出年份唯一依据；ref: openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:9; 非法 `ID` 格式计为失败并继续后续条目；ref: openspec/changes/cve-poc-llm-reports/tasks.md:10; 年份解析不能依赖 `file_path` 年份目录；ref: openspec/changes/cve-poc-llm-reports/design.md:15,AUTOSERVER,年份解析规则（regex）需有单测覆盖边界：非 CVE 前缀、YYYY 非数字、年份越界；失败条目的统计/日志必须包含 `ID` 原值。,路径映射年份必须使用解析出的 year（即使 file_path 年份不一致）；ref: openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:39,已完成,已完成,已完成,已提交,,openspec/changes/cve-poc-llm-reports/tasks.md:10; openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:9; openspec/changes/cve-poc-llm-reports/design.md:15; cve_poc_llm_reports/cves_jsonl.py:39; tests/test_cves_jsonl.py:73,picked_reason:年份解析是 from-year 过滤与 report_path 年份的唯一依据，优先固化规则与单测; done_at:2026-02-03; evidence:python3 -m unittest discover -s tests -v (TestParseCveYearFromId); evidence:parse rejects bad prefix/non-digit year/out-of-range year with raw ID in error
CPLR-02-03,P2,2,backend,实现 --from-year 过滤（year >= from_year）,支持 from_year 参数，仅处理解析年份 >= from_year 的条目；被过滤条目必须不读取模板、不生成报告、不写索引。,MUST 支持 `from_year` 参数并仅处理 `year >= from_year`；ref: openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:16; WHEN `from_year=2025` 且条目年份为 2024 → THEN 跳过且不读模板/不生成报告/不写索引；ref: openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:19; 跳过原因需可观测（日志包含 from_year 与条目 year）；ref: openspec/changes/cve-poc-llm-reports/tasks.md:11,AUTOSERVER,过滤逻辑必须在任何 IO/模型调用前执行（成本/速率风险）；from_year 取值校验（非数字/小于 0/过大）必须有明确错误。,支持增量与已生成跳过以降低成本与速率限制风险；ref: openspec/changes/cve-poc-llm-reports/design.md:59,已完成,已完成,已完成,已提交,,openspec/changes/cve-poc-llm-reports/tasks.md:11; openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:19; openspec/changes/cve-poc-llm-reports/design.md:59; scripts/cve_poc_llm_reports.py:167; scripts/cve_poc_llm_reports.py:250; tests/test_from_year_filter.py:1,picked_reason:from-year 过滤是增量跑批的成本闸门，需最先保证在任何 IO/模型调用前生效; done_at:2026-02-03; evidence:python3 -m unittest discover -s tests -v (test_from_year_filter); evidence:skip log includes from_year and entry year before any template/model IO
CPLR-03-01,P2,3,backend,实现 report_path 映射（reports/<prefix>/cves/<year>/<ID>.json）,根据 file_path 前缀与 ID 解析年份生成 report_path：reports/<prefix>/cves/<year>/<ID>.json；年份必须来自 ID，不受 file_path 年份不一致影响。,报告路径根目录 MUST 为 `reports/` 且保留 `cves/` 之前的前缀；ref: openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:27; 报告路径中的年份目录 MUST 使用 `ID` 解析年份（而非 file_path 年份）；ref: openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:29; WHEN `ID` 年份与 file_path 年份不一致 → THEN 仍使用 `ID` 年份；ref: openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:40,AUTOSERVER,路径映射需覆盖 spec 示例（包含年份不一致示例）；prefix 提取必须基于 `cves/` 分隔，若缺失 `cves/` 需明确失败策略；必须防止生成仓库外路径（禁用 `..` 等）。,回归检查 report_path 规则与 design 决策一致（非按 ID 扁平存储）；ref: openspec/changes/cve-poc-llm-reports/design.md:36,已完成,已完成,已完成,已提交,,openspec/changes/cve-poc-llm-reports/tasks.md:15; openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:22; openspec/changes/cve-poc-llm-reports/design.md:36; cve_poc_llm_reports/report_paths.py:6; tests/test_report_paths.py:1,picked_reason:report_path 映射是输出落盘与幂等判断的关键键，先固化规则以解锁后续 skip/写入/索引; done_at:2026-02-03; evidence:python3 -m unittest discover -s tests -v (test_report_paths); evidence:report_path uses ID year (not file_path year) and preserves prefix before /cves/
CPLR-03-02,P2,3,backend,幂等：report_path 已存在则跳过且不调用模型,在生成报告前检查 report_path 是否存在：存在则跳过该 CVE（不调用模型、不写索引），继续处理后续条目。,MUST 以 report_path 文件是否存在作为增量跳过依据；ref: openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:44; WHEN `reports/.../<ID>.json` 已存在 → THEN 不重复生成且不重复写索引；ref: openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:47; 跳过原因需记录到日志并包含 `ID` 与 report_path；ref: openspec/changes/cve-poc-llm-reports/tasks.md:16,AUTOSERVER,存在性检查必须发生在任何模型调用与索引写入之前；若索引已有条目但文件缺失，不应跳过（以文件为准的决策）；ref: openspec/changes/cve-poc-llm-reports/design.md:41,回归确认索引仅追加新生成条目，不要求重建/去重；ref: openspec/changes/cve-poc-llm-reports/design.md:41,未开始,未开始,未开始,未提交,,openspec/changes/cve-poc-llm-reports/tasks.md:16; openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:44; openspec/changes/cve-poc-llm-reports/design.md:40,
CPLR-03-03,P2,3,backend,确保 reports 目录树存在（mkdir -p）,在写入报告前创建 report_path 所在目录树，避免因目录缺失导致生成失败。,写入前确保 `reports/...` 目录树存在；ref: openspec/changes/cve-poc-llm-reports/tasks.md:17; 报告文件写入路径必须落在 `reports/` 下；ref: openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:27,AUTOSERVER,目录创建需幂等（已存在不报错），并避免跟随到符号链接导致越界写入；临时文件写入（如采用）应放在同目录确保原子替换可用。,回归确认仅新增/写入 `reports/` 与 `reports/cves.jsonl`；ref: openspec/changes/cve-poc-llm-reports/design.md:18,未开始,未开始,未开始,未提交,,openspec/changes/cve-poc-llm-reports/tasks.md:17; openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:27; openspec/changes/cve-poc-llm-reports/design.md:18,
CPLR-04-01,P2,4,backend,封装 OpenAI Chat 调用（POST <base_url>/v1/chat/completions）,实现对 OpenAI 标准 Chat 接口的 HTTP 调用：Authorization Bearer api_key，请求体包含 model/messages，base_url 可配置且不写死域名。,请求发送到 `POST <base_url>/v1/chat/completions`，并允许配置 `base_url/api_key/model`；ref: openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:57; WHEN 配置非默认 base_url → THEN 向该 base_url 的标准路径请求；ref: openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:60; 请求包含 Authorization Bearer 与 model/messages；ref: openspec/changes/cve-poc-llm-reports/tasks.md:21,CONTRACT,严格遵守 OpenAI Chat 契约（URL 拼接、headers、JSON 序列化），base_url 支持带/不带尾斜杠；必须设置合理超时，错误需返回结构化信息（status/body 摘要），不得吞异常；不得记录完整请求体（可能含敏感模板内容/密钥）。,回归确认未引入强依赖特定 SDK（仅标准 HTTP 接口）；ref: openspec/changes/cve-poc-llm-reports/design.md:54,未开始,未开始,未开始,未提交,,openspec/changes/cve-poc-llm-reports/tasks.md:21; openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:57; openspec/changes/cve-poc-llm-reports/design.md:52,
CPLR-04-02,P2,4,backend,强制 JSON 输出策略（response_format 优先，失败回退）,实现“严格 JSON”输出：服务端支持时使用 response_format；否则使用严格提示词 + JSON 解析校验 + 有界重试；失败返回结构化错误供上层记录并继续。,优先使用 `response_format` 强制 JSON；不支持时回退到严格提示词 + JSON 解析校验；ref: openspec/changes/cve-poc-llm-reports/design.md:53; LLM 输出不稳定/非 JSON 时：校验失败触发有界重试，最终失败需记录并继续；ref: openspec/changes/cve-poc-llm-reports/design.md:58; 报告 JSON 必须满足 required fields 与枚举约束；ref: openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:64,CONTRACT,JSON 解析必须严格（禁止容忍尾随文本），并对“可重试/不可重试”错误分类；重试次数必须有上限且可配置；prompt 不得要求溯源证据（只要结果型信号的决策）；ref: openspec/changes/cve-poc-llm-reports/design.md:48,回归确认单条 CVE 失败不会写入半成品报告/索引；ref: openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:94,未开始,未开始,未开始,未提交,,openspec/changes/cve-poc-llm-reports/tasks.md:22; openspec/changes/cve-poc-llm-reports/design.md:53; openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:94,风险：输出非 JSON；Mitigation：response_format/严格提示词+解析校验+重试；ref: openspec/changes/cve-poc-llm-reports/design.md:58
CPLR-04-03,P2,4,backend,实现有界重试与超时（失败可继续批处理）,为模型调用提供超时与有界重试；失败返回结构化错误，上层记录后继续后续 CVE。,实现超时与有界重试（可配置或合理默认）；ref: openspec/changes/cve-poc-llm-reports/tasks.md:23; 失败时必须继续后续 CVE，且 MUST NOT 写入不完整报告/索引；ref: openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:94,CONTRACT,重试需避免无穷循环，建议包含指数退避/抖动（如实现）；超时应覆盖连接与读写；错误结构需包含可排障信息（HTTP 状态码/错误码/响应摘要），同时避免泄露敏感数据。,回归确认成本与速率限制风险可控（from-year + skip + 有界重试）；ref: openspec/changes/cve-poc-llm-reports/design.md:59,未开始,未开始,未开始,未提交,,openspec/changes/cve-poc-llm-reports/tasks.md:23; openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:94; openspec/changes/cve-poc-llm-reports/design.md:59,
CPLR-05-01,P2,5,backend,固化 report schema v1 并做最小字段校验,固化 schema_version=v1 与必需字段集合（cve/template/signals），在写入前进行最小字段/枚举校验，避免落盘无效报告。,报告 JSON MUST 至少包含 `schema_version/cve/template/signals` 与 signals 必需字段；ref: openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:66; signals 枚举值与类型满足 spec（exploit_vs_detect/auth_requirement/oast_required 等）；ref: openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:71; 写入前进行最小校验，校验失败视为该 CVE 失败且不写报告/索引；ref: openspec/changes/cve-poc-llm-reports/tasks.md:27,CONTRACT,schema 校验应与生成逻辑解耦（便于单测），并提供清晰的错误信息（缺失字段/类型不符/枚举非法）；severity 缺失时必须为 `unknown`（默认值规则）。,回归确认输出为“结果型信号”而非溯源证据（避免 schema 漂移）；ref: openspec/changes/cve-poc-llm-reports/design.md:48,未开始,未开始,未开始,未提交,,openspec/changes/cve-poc-llm-reports/tasks.md:27; openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:63; openspec/changes/cve-poc-llm-reports/design.md:48,
CPLR-05-02,P2,5,backend,设计并实现 LLM 提示词（输入 ID/路径/YAML，输出严格 JSON）,实现提示词模板：输入 ID、nuclei-templates/<file_path> 与模板 YAML 原文（必要时结构摘要），输出严格 JSON 的结果型信号。,输入包含 `ID` + `nuclei-templates/<file_path>` + 模板 YAML 原文（必要时可加结构摘要）；ref: openspec/changes/cve-poc-llm-reports/design.md:45; 输出严格 JSON，且 signals 只要结果不要求溯源解释；ref: openspec/changes/cve-poc-llm-reports/design.md:49; 生成的报告满足 required schema；ref: openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:79,CONTRACT,prompt 应尽量短且稳定（减少漂移），禁止把“模板行号证据”作为必需输出；考虑模板过长超上下文的降级策略（抽取关键结构）；ref: openspec/changes/cve-poc-llm-reports/design.md:60,回归确认超长模板降级模式会被记录到报告元信息（若实现），并不影响批处理继续；ref: openspec/changes/cve-poc-llm-reports/design.md:60,未开始,未开始,未开始,未提交,,openspec/changes/cve-poc-llm-reports/tasks.md:28; openspec/changes/cve-poc-llm-reports/design.md:45; openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:77,
CPLR-05-03,P2,5,backend,生成报告 JSON 并原子写入（临时文件→替换）,生成报告 JSON 写入 report_path；写入采用“临时文件→原子替换”避免半写入/损坏文件。,报告写入 report_path，且写入过程采用临时文件→原子替换；ref: openspec/changes/cve-poc-llm-reports/tasks.md:29; 发生任意失败时 MUST NOT 生成不完整的报告文件；ref: openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:94,AUTOSERVER,临时文件必须与目标文件同目录（保证 rename 原子性），失败时需清理；写入前后最好做 fsync（如实现）或至少确保关闭文件句柄；避免并发写同一路径（若支持 concurrency，需要锁/原子策略）。,回归确认不会因中断留下半写入文件或坏 JSON；ref: openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:94,未开始,未开始,未开始,未提交,,openspec/changes/cve-poc-llm-reports/tasks.md:29; openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:94; openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:23,
CPLR-06-01,P2,6,backend,维护 reports/cves.jsonl 索引（追加写）,对每个成功生成的新报告，向 reports/cves.jsonl 追加一行 JSONL，至少包含 ID 与 report_path（相对仓库根）。,"MUST 对每个成功生成报告的 CVE 向 `reports/cves.jsonl` 追加 `{ID, report_path}`；ref: openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:84; WHEN 首次生成报告 → THEN 追加索引行；ref: openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:90; 索引写入为追加模式，不要求重建/去重；ref: openspec/changes/cve-poc-llm-reports/design.md:41",AUTOSERVER,索引行必须是单行 JSON（无多行/缩进），并确保每次追加带换行符；report_path 必须为相对路径且与实际报告路径一致；索引写入失败需作为该 CVE 失败处理（不要产生报告无索引或索引指向不存在文件）。,回归确认 index 不作为跳过依据（以文件存在为准）；ref: openspec/changes/cve-poc-llm-reports/design.md:42,未开始,未开始,未开始,未提交,,openspec/changes/cve-poc-llm-reports/tasks.md:33; openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:83; openspec/changes/cve-poc-llm-reports/design.md:41,
CPLR-06-02,P2,6,backend,索引仅写入“本次成功生成的新报告”,仅对本次成功新生成的报告写索引：跳过（已存在）与失败条目不得写入索引行。,仅对“本次成功生成的新报告”追加索引，跳过与失败不写；ref: openspec/changes/cve-poc-llm-reports/tasks.md:34; 报告已存在的二次运行不得重复写索引；ref: openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:48; 失败条目 MUST NOT 写入报告与索引；ref: openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:94,AUTOSERVER,需要明确区分：skip/failed/success-new 三类状态，并做计数统计；索引追加逻辑需与幂等跳过逻辑一致（同一处判定点）。,回归确认索引缺失/截断不会导致跳过（仍以文件存在为准）；ref: openspec/changes/cve-poc-llm-reports/design.md:42,未开始,未开始,未开始,未提交,,openspec/changes/cve-poc-llm-reports/tasks.md:34; openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:48; openspec/changes/cve-poc-llm-reports/design.md:42,
CPLR-07-01,P2,7,backend,失败处理：记录原因并继续后续 CVE（不产出半成品）,对缺失模板文件、JSONL 解析失败、模型输出不可解析等情况，记录失败原因并继续后续 CVE；不得生成不完整的报告文件或索引行。,对模板缺失/JSONL 解析失败/模型输出不可解析等情况：记录失败并继续；ref: openspec/changes/cve-poc-llm-reports/tasks.md:38; 失败时 MUST NOT 生成不完整报告或索引行；ref: openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:94; WHEN 模型调用失败 → THEN 不写报告/索引并继续下一条；ref: openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:100,AUTOSERVER,失败记录必须包含：CVE ID、file_path、失败类型、可重试与否、错误摘要；需要保证批处理最终能完成（即使有失败条目）。,回归确认 LLM 非 JSON/调用失败等风险已有 mitigation（response_format/重试/继续）；ref: openspec/changes/cve-poc-llm-reports/design.md:58,未开始,未开始,未开始,未提交,,openspec/changes/cve-poc-llm-reports/tasks.md:38; openspec/changes/cve-poc-llm-reports/specs/cve-poc-llm-reporting/spec.md:93; openspec/changes/cve-poc-llm-reports/design.md:58,
CPLR-07-02,P2,7,backend,增加最小自检命令（两条可复现生成/跳过验证）,在文档中补充两条可复现命令：对 CVE-2021-44228 与 CVE-2025-49844 的生成/跳过验证，覆盖 from-year 与幂等跳过。,文档中包含两条可复现命令（CVE-2021-44228、CVE-2025-49844），并说明预期行为（首次生成/二次跳过）；ref: openspec/changes/cve-poc-llm-reports/tasks.md:39; 命令示例覆盖 `--from-year` 与“已生成则跳过”；ref: openspec/changes/cve-poc-llm-reports/proposal.md:11,MANUAL,命令需明确依赖（templates_dir/reports_dir/base_url/api_key/model）与环境变量示例；给出最小预期输出（例如应生成的 report_path、index 追加/不追加）。,回归确认自检命令不需要修改 `nuclei-templates/`，且可用于增量重跑验证；ref: openspec/changes/cve-poc-llm-reports/proposal.md:3,未开始,未开始,未开始,未提交,,openspec/changes/cve-poc-llm-reports/tasks.md:39; openspec/changes/cve-poc-llm-reports/proposal.md:7; openspec/changes/cve-poc-llm-reports/proposal.md:11,proposal.md 未提供 Risk Assessment/Breaking Changes/Rollback 表格；若需回滚，删除 `reports/` 输出并回退提交即可。
